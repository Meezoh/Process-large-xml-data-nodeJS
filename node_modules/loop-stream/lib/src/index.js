"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loopStream = void 0;
function loopStream(stream, iterOrAcc, iterWithState) {
    const __keepsState = !(iterOrAcc instanceof Function);
    if (!__keepsState) {
        return loopStreamWithoutState(stream, iterOrAcc);
    }
    return loopStreamWithState(stream, iterOrAcc, iterWithState);
}
exports.loopStream = loopStream;
function loopStreamWithoutState(stream, iter) {
    if (stream.destroyed) {
        return Promise.resolve();
    }
    return new Promise((res, rej) => {
        const cleanup = () => {
            stream.off('error', rej);
            stream.off('readable', onReadable);
            stream.off('end', onEnd);
        };
        const onEnd = () => {
            cleanup();
            res();
        };
        let chunk;
        const onReadable = () => {
            try {
                while ((chunk = stream.read()) !== null) {
                    const result = iter(chunk);
                    if (result.action === 'continue') {
                        continue;
                    }
                    cleanup();
                    if (typeof result.unconsumedData !== undefined) {
                        stream.unshift(result.unconsumedData);
                    }
                    res();
                    break;
                }
            }
            catch (err) {
                rej(err);
            }
        };
        stream.on('error', rej);
        onReadable();
        stream.on('readable', onReadable);
        stream.on('end', onEnd);
    });
}
function loopStreamWithState(stream, acc, iter) {
    if (stream.destroyed) {
        return Promise.resolve(acc);
    }
    let chunk;
    return new Promise((res, rej) => {
        const cleanup = () => {
            stream.off('error', rej);
            stream.off('readable', onReadable);
            stream.off('end', onEnd);
        };
        const onEnd = () => {
            cleanup();
            res(acc);
        };
        const onReadable = () => {
            try {
                while ((chunk = stream.read()) !== null) {
                    const result = iter(chunk, acc);
                    acc = result.acc;
                    if (result.action === 'continue') {
                        continue;
                    }
                    cleanup();
                    if (typeof result.unconsumedData !== 'undefined') {
                        stream.unshift(result.unconsumedData);
                    }
                    res(acc);
                    break;
                }
            }
            catch (err) {
                rej(err);
            }
        };
        stream.on('error', rej);
        onReadable();
        stream.on('readable', onReadable);
        stream.on('end', onEnd);
    });
}
//# sourceMappingURL=index.js.map