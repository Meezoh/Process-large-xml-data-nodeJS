"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const src_1 = require("../src");
describe('Use case: Respond Hello to stdin', () => {
    const createStdio = () => {
        const stdin = new stream_1.PassThrough({ objectMode: true });
        stdin.write('Yo\n');
        stdin.write('Hi\n');
        stdin.write('I want to be read too!\n');
        stdin.end();
        const stdout = new stream_1.PassThrough({ objectMode: true });
        return { stdin, stdout };
    };
    it('fails to read stdin after partial consumption using async iterator', async () => {
        const { stdin, stdout } = createStdio();
        let lastReadChunk;
        for await (const chunk of stdin) {
            lastReadChunk = chunk;
            if (chunk === 'Hi\n') {
                stdout.write('Hello');
                break;
            }
        }
        expect(lastReadChunk).toBe('Hi\n');
        expect(stdout.read()).toBe('Hello');
        let chunkReadLater = null;
        for await (const chunk of stdin) {
            chunkReadLater = chunk;
        }
        expect(chunkReadLater).toEqual(null);
    });
    it('allows to read stdin after partial consumption using loopStream', async () => {
        const { stdin, stdout } = createStdio();
        let lastReadChunk;
        await src_1.loopStream(stdin, chunk => {
            lastReadChunk = chunk;
            if (chunk === 'Hi\n') {
                stdout.write('Hello');
                return { action: 'break' };
            }
            return { action: 'continue' };
        });
        expect(lastReadChunk).toBe('Hi\n');
        expect(stdout.read()).toBe('Hello');
        let chunkReadLater = null;
        for await (const chunk of stdin) {
            chunkReadLater = chunk;
        }
        expect(chunkReadLater).toEqual('I want to be read too!\n');
    });
});
//# sourceMappingURL=respond-hello-to-stdin.spec.js.map